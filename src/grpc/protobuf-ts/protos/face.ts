// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "protos/face.proto" (package "face", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message face.GetEmptyRequest
 */
export interface GetEmptyRequest {
}
/**
 * @generated from protobuf message face.RegisterByImageRequest
 */
export interface RegisterByImageRequest {
    /**
     * @generated from protobuf field: uint32 uid = 1;
     */
    uid: number;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: string imageData = 3;
     */
    imageData: string;
}
/**
 * @generated from protobuf message face.ImageMessage
 */
export interface ImageMessage {
    /**
     * @generated from protobuf field: string url = 1;
     */
    url: string;
    /**
     * @generated from protobuf field: uint32 uid = 2;
     */
    uid: number;
    /**
     * @generated from protobuf field: string employeeNo = 3;
     */
    employeeNo: string;
    /**
     * @generated from protobuf field: string imageData = 4;
     */
    imageData: string;
}
/**
 * @generated from protobuf message face.ImageReply
 */
export interface ImageReply {
    /**
     * @generated from protobuf field: bool result = 1;
     */
    result: boolean;
    /**
     * @generated from protobuf field: string message = 2;
     */
    message: string;
}
/**
 * @generated from protobuf message face.GetUrlRequest
 */
export interface GetUrlRequest {
    /**
     * @generated from protobuf field: string url = 1;
     */
    url: string;
}
/**
 * @generated from protobuf message face.GetUrlFaceRequest
 */
export interface GetUrlFaceRequest {
    /**
     * @generated from protobuf field: string url = 1;
     */
    url: string;
    /**
     * @generated from protobuf field: string uuid = 2;
     */
    uuid: string;
}
/**
 * @generated from protobuf message face.GetFaceUuidRequest
 */
export interface GetFaceUuidRequest {
    /**
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
}
/**
 * @generated from protobuf message face.GetUrlFaceByUserRequest
 */
export interface GetUrlFaceByUserRequest {
    /**
     * @generated from protobuf field: string url = 1;
     */
    url: string;
    /**
     * @generated from protobuf field: uint32 uid = 2;
     */
    uid: number;
    /**
     * @generated from protobuf field: string phoneNo = 3;
     */
    phoneNo: string;
    /**
     * @generated from protobuf field: string employeeNo = 4;
     */
    employeeNo: string;
    /**
     * @generated from protobuf field: string username = 5;
     */
    username: string;
}
/**
 * @generated from protobuf message face.GetUrlDeviceIdRequest
 */
export interface GetUrlDeviceIdRequest {
    /**
     * @generated from protobuf field: string url = 1;
     */
    url: string;
    /**
     * @generated from protobuf field: string deviceId = 2;
     */
    deviceId: string;
}
/**
 * @generated from protobuf message face.GetFnoRequest
 */
export interface GetFnoRequest {
    /**
     * @generated from protobuf field: uint32 fno = 1;
     */
    fno: number;
}
/**
 * @generated from protobuf message face.GetFeatureRequest
 */
export interface GetFeatureRequest {
    /**
     * @generated from protobuf field: string feature = 1;
     */
    feature: string;
}
/**
 * @generated from protobuf message face.GetFnoFeatureRequest
 */
export interface GetFnoFeatureRequest {
    /**
     * @generated from protobuf field: uint32 fno = 1;
     */
    fno: number;
    /**
     * @generated from protobuf field: string feature = 2;
     */
    feature: string;
}
/**
 * @generated from protobuf message face.GetRecordUserRequest
 */
export interface GetRecordUserRequest {
    /**
     * @generated from protobuf field: string url = 1;
     */
    url: string;
    /**
     * @generated from protobuf field: string deviceId = 2;
     */
    deviceId: string;
    /**
     * @generated from protobuf field: uint32 uid = 3;
     */
    uid: number;
}
/**
 * @generated from protobuf message face.Res
 */
export interface Res {
    /**
     * @generated from protobuf field: string result = 1;
     */
    result: string;
    /**
     * @generated from protobuf field: string error = 2;
     */
    error: string;
}
/**
 * @generated from protobuf message face.ResFace
 */
export interface ResFace {
    /**
     * @generated from protobuf field: string result = 1;
     */
    result: string;
    /**
     * @generated from protobuf field: string error = 2;
     */
    error: string;
    /**
     * @generated from protobuf field: string featureData = 3;
     */
    featureData: string;
    /**
     *  string featureData2 =4;
     *
     * @generated from protobuf field: string imageData = 4;
     */
    imageData: string;
}
/**
 * @generated from protobuf message face.ResData
 */
export interface ResData {
    /**
     * @generated from protobuf field: string result = 1;
     */
    result: string;
    /**
     * @generated from protobuf field: string error = 2;
     */
    error: string;
    /**
     * @generated from protobuf field: repeated face.ServiceInfo data = 3;
     */
    data: ServiceInfo[];
}
/**
 * @generated from protobuf message face.ServiceInfo
 */
export interface ServiceInfo {
    /**
     * @generated from protobuf field: string deviceId = 1;
     */
    deviceId: string;
    /**
     * @generated from protobuf field: string serviceId = 2;
     */
    serviceId: string;
    /**
     * @generated from protobuf field: string status = 3;
     */
    status: string;
}
/**
 * @generated from protobuf message face.ResMsg
 */
export interface ResMsg {
    /**
     * @generated from protobuf field: string result = 1;
     */
    result: string;
    /**
     * @generated from protobuf field: string error = 2;
     */
    error: string;
    /**
     * @generated from protobuf field: string msg = 3;
     */
    msg: string;
}
/**
 * @generated from protobuf message face.ResRecordMsg
 */
export interface ResRecordMsg {
    /**
     * @generated from protobuf field: string result = 1;
     */
    result: string;
    /**
     * @generated from protobuf field: uint32 fno = 2;
     */
    fno: number;
    /**
     * @generated from protobuf field: uint32 right = 3;
     */
    right: number;
    /**
     * @generated from protobuf field: string feature = 4;
     */
    feature: string;
    /**
     * @generated from protobuf field: string msg = 5;
     */
    msg: string;
    /**
     * @generated from protobuf field: uint32 length = 6;
     */
    length: number;
    /**
     * @generated from protobuf field: string error = 7;
     */
    error: string;
}
/**
 * @generated from protobuf message face.ResVersion
 */
export interface ResVersion {
    /**
     * @generated from protobuf field: string result = 1;
     */
    result: string;
    /**
     * @generated from protobuf field: string version = 2;
     */
    version: string;
}
/**
 * @generated from protobuf message face.ResTotal
 */
export interface ResTotal {
    /**
     * @generated from protobuf field: string result = 1;
     */
    result: string;
    /**
     * @generated from protobuf field: uint32 total = 2;
     */
    total: number;
}
/**
 * @generated from protobuf message face.ResFno
 */
export interface ResFno {
    /**
     * @generated from protobuf field: string result = 1;
     */
    result: string;
    /**
     * @generated from protobuf field: uint32 fno = 2;
     */
    fno: number;
    /**
     * @generated from protobuf field: uint32 right = 3;
     */
    right: number;
    /**
     * @generated from protobuf field: string error = 4;
     */
    error: string;
}
/**
 * @generated from protobuf message face.ResUserRight
 */
export interface ResUserRight {
    /**
     * @generated from protobuf field: string result = 1;
     */
    result: string;
    /**
     * @generated from protobuf field: uint32 fno = 2;
     */
    fno: number;
    /**
     * @generated from protobuf field: uint32 right = 3;
     */
    right: number;
}
/**
 * @generated from protobuf message face.ResUserInfo
 */
export interface ResUserInfo {
    /**
     * @generated from protobuf field: string result = 1;
     */
    result: string;
    /**
     * @generated from protobuf field: uint32 total = 2;
     */
    total: number;
    /**
     * @generated from protobuf field: repeated face.UserInfo data = 3;
     */
    data: UserInfo[];
}
/**
 * @generated from protobuf message face.UserInfo
 */
export interface UserInfo {
    /**
     * @generated from protobuf field: uint32 fno = 1;
     */
    fno: number;
    /**
     * @generated from protobuf field: uint32 right = 2;
     */
    right: number;
}
/**
 * @generated from protobuf message face.ResFeature
 */
export interface ResFeature {
    /**
     * @generated from protobuf field: string result = 1;
     */
    result: string;
    /**
     * @generated from protobuf field: uint32 fno = 2;
     */
    fno: number;
    /**
     * @generated from protobuf field: uint32 right = 3;
     */
    right: number;
    /**
     * @generated from protobuf field: string feature = 4;
     */
    feature: string;
}
/**
 * @generated from protobuf message face.ResFnoList
 */
export interface ResFnoList {
    /**
     * @generated from protobuf field: string result = 1;
     */
    result: string;
    /**
     * @generated from protobuf field: repeated uint32 fnoList = 2;
     */
    fnoList: number[];
    /**
     * @generated from protobuf field: string error = 3;
     */
    error: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class GetEmptyRequest$Type extends MessageType<GetEmptyRequest> {
    constructor() {
        super("face.GetEmptyRequest", []);
    }
    create(value?: PartialMessage<GetEmptyRequest>): GetEmptyRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetEmptyRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetEmptyRequest): GetEmptyRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetEmptyRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message face.GetEmptyRequest
 */
export const GetEmptyRequest = new GetEmptyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterByImageRequest$Type extends MessageType<RegisterByImageRequest> {
    constructor() {
        super("face.RegisterByImageRequest", [
            { no: 1, name: "uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "imageData", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RegisterByImageRequest>): RegisterByImageRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uid = 0;
        message.name = "";
        message.imageData = "";
        if (value !== undefined)
            reflectionMergePartial<RegisterByImageRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterByImageRequest): RegisterByImageRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 uid */ 1:
                    message.uid = reader.uint32();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string imageData */ 3:
                    message.imageData = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegisterByImageRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 uid = 1; */
        if (message.uid !== 0)
            writer.tag(1, WireType.Varint).uint32(message.uid);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string imageData = 3; */
        if (message.imageData !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.imageData);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message face.RegisterByImageRequest
 */
export const RegisterByImageRequest = new RegisterByImageRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImageMessage$Type extends MessageType<ImageMessage> {
    constructor() {
        super("face.ImageMessage", [
            { no: 1, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "employeeNo", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "imageData", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ImageMessage>): ImageMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.url = "";
        message.uid = 0;
        message.employeeNo = "";
        message.imageData = "";
        if (value !== undefined)
            reflectionMergePartial<ImageMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImageMessage): ImageMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string url */ 1:
                    message.url = reader.string();
                    break;
                case /* uint32 uid */ 2:
                    message.uid = reader.uint32();
                    break;
                case /* string employeeNo */ 3:
                    message.employeeNo = reader.string();
                    break;
                case /* string imageData */ 4:
                    message.imageData = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImageMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string url = 1; */
        if (message.url !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.url);
        /* uint32 uid = 2; */
        if (message.uid !== 0)
            writer.tag(2, WireType.Varint).uint32(message.uid);
        /* string employeeNo = 3; */
        if (message.employeeNo !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.employeeNo);
        /* string imageData = 4; */
        if (message.imageData !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.imageData);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message face.ImageMessage
 */
export const ImageMessage = new ImageMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImageReply$Type extends MessageType<ImageReply> {
    constructor() {
        super("face.ImageReply", [
            { no: 1, name: "result", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ImageReply>): ImageReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = false;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<ImageReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImageReply): ImageReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool result */ 1:
                    message.result = reader.bool();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImageReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool result = 1; */
        if (message.result !== false)
            writer.tag(1, WireType.Varint).bool(message.result);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message face.ImageReply
 */
export const ImageReply = new ImageReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetUrlRequest$Type extends MessageType<GetUrlRequest> {
    constructor() {
        super("face.GetUrlRequest", [
            { no: 1, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetUrlRequest>): GetUrlRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.url = "";
        if (value !== undefined)
            reflectionMergePartial<GetUrlRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUrlRequest): GetUrlRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string url */ 1:
                    message.url = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetUrlRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string url = 1; */
        if (message.url !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.url);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message face.GetUrlRequest
 */
export const GetUrlRequest = new GetUrlRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetUrlFaceRequest$Type extends MessageType<GetUrlFaceRequest> {
    constructor() {
        super("face.GetUrlFaceRequest", [
            { no: 1, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetUrlFaceRequest>): GetUrlFaceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.url = "";
        message.uuid = "";
        if (value !== undefined)
            reflectionMergePartial<GetUrlFaceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUrlFaceRequest): GetUrlFaceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string url */ 1:
                    message.url = reader.string();
                    break;
                case /* string uuid */ 2:
                    message.uuid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetUrlFaceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string url = 1; */
        if (message.url !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.url);
        /* string uuid = 2; */
        if (message.uuid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.uuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message face.GetUrlFaceRequest
 */
export const GetUrlFaceRequest = new GetUrlFaceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFaceUuidRequest$Type extends MessageType<GetFaceUuidRequest> {
    constructor() {
        super("face.GetFaceUuidRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetFaceUuidRequest>): GetFaceUuidRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        if (value !== undefined)
            reflectionMergePartial<GetFaceUuidRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFaceUuidRequest): GetFaceUuidRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetFaceUuidRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message face.GetFaceUuidRequest
 */
export const GetFaceUuidRequest = new GetFaceUuidRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetUrlFaceByUserRequest$Type extends MessageType<GetUrlFaceByUserRequest> {
    constructor() {
        super("face.GetUrlFaceByUserRequest", [
            { no: 1, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "phoneNo", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "employeeNo", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetUrlFaceByUserRequest>): GetUrlFaceByUserRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.url = "";
        message.uid = 0;
        message.phoneNo = "";
        message.employeeNo = "";
        message.username = "";
        if (value !== undefined)
            reflectionMergePartial<GetUrlFaceByUserRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUrlFaceByUserRequest): GetUrlFaceByUserRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string url */ 1:
                    message.url = reader.string();
                    break;
                case /* uint32 uid */ 2:
                    message.uid = reader.uint32();
                    break;
                case /* string phoneNo */ 3:
                    message.phoneNo = reader.string();
                    break;
                case /* string employeeNo */ 4:
                    message.employeeNo = reader.string();
                    break;
                case /* string username */ 5:
                    message.username = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetUrlFaceByUserRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string url = 1; */
        if (message.url !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.url);
        /* uint32 uid = 2; */
        if (message.uid !== 0)
            writer.tag(2, WireType.Varint).uint32(message.uid);
        /* string phoneNo = 3; */
        if (message.phoneNo !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.phoneNo);
        /* string employeeNo = 4; */
        if (message.employeeNo !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.employeeNo);
        /* string username = 5; */
        if (message.username !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.username);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message face.GetUrlFaceByUserRequest
 */
export const GetUrlFaceByUserRequest = new GetUrlFaceByUserRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetUrlDeviceIdRequest$Type extends MessageType<GetUrlDeviceIdRequest> {
    constructor() {
        super("face.GetUrlDeviceIdRequest", [
            { no: 1, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "deviceId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetUrlDeviceIdRequest>): GetUrlDeviceIdRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.url = "";
        message.deviceId = "";
        if (value !== undefined)
            reflectionMergePartial<GetUrlDeviceIdRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUrlDeviceIdRequest): GetUrlDeviceIdRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string url */ 1:
                    message.url = reader.string();
                    break;
                case /* string deviceId */ 2:
                    message.deviceId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetUrlDeviceIdRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string url = 1; */
        if (message.url !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.url);
        /* string deviceId = 2; */
        if (message.deviceId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.deviceId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message face.GetUrlDeviceIdRequest
 */
export const GetUrlDeviceIdRequest = new GetUrlDeviceIdRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFnoRequest$Type extends MessageType<GetFnoRequest> {
    constructor() {
        super("face.GetFnoRequest", [
            { no: 1, name: "fno", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetFnoRequest>): GetFnoRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fno = 0;
        if (value !== undefined)
            reflectionMergePartial<GetFnoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFnoRequest): GetFnoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 fno */ 1:
                    message.fno = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetFnoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 fno = 1; */
        if (message.fno !== 0)
            writer.tag(1, WireType.Varint).uint32(message.fno);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message face.GetFnoRequest
 */
export const GetFnoRequest = new GetFnoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFeatureRequest$Type extends MessageType<GetFeatureRequest> {
    constructor() {
        super("face.GetFeatureRequest", [
            { no: 1, name: "feature", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetFeatureRequest>): GetFeatureRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.feature = "";
        if (value !== undefined)
            reflectionMergePartial<GetFeatureRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFeatureRequest): GetFeatureRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string feature */ 1:
                    message.feature = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetFeatureRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string feature = 1; */
        if (message.feature !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.feature);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message face.GetFeatureRequest
 */
export const GetFeatureRequest = new GetFeatureRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFnoFeatureRequest$Type extends MessageType<GetFnoFeatureRequest> {
    constructor() {
        super("face.GetFnoFeatureRequest", [
            { no: 1, name: "fno", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "feature", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetFnoFeatureRequest>): GetFnoFeatureRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fno = 0;
        message.feature = "";
        if (value !== undefined)
            reflectionMergePartial<GetFnoFeatureRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFnoFeatureRequest): GetFnoFeatureRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 fno */ 1:
                    message.fno = reader.uint32();
                    break;
                case /* string feature */ 2:
                    message.feature = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetFnoFeatureRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 fno = 1; */
        if (message.fno !== 0)
            writer.tag(1, WireType.Varint).uint32(message.fno);
        /* string feature = 2; */
        if (message.feature !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.feature);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message face.GetFnoFeatureRequest
 */
export const GetFnoFeatureRequest = new GetFnoFeatureRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRecordUserRequest$Type extends MessageType<GetRecordUserRequest> {
    constructor() {
        super("face.GetRecordUserRequest", [
            { no: 1, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "deviceId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetRecordUserRequest>): GetRecordUserRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.url = "";
        message.deviceId = "";
        message.uid = 0;
        if (value !== undefined)
            reflectionMergePartial<GetRecordUserRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRecordUserRequest): GetRecordUserRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string url */ 1:
                    message.url = reader.string();
                    break;
                case /* string deviceId */ 2:
                    message.deviceId = reader.string();
                    break;
                case /* uint32 uid */ 3:
                    message.uid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetRecordUserRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string url = 1; */
        if (message.url !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.url);
        /* string deviceId = 2; */
        if (message.deviceId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.deviceId);
        /* uint32 uid = 3; */
        if (message.uid !== 0)
            writer.tag(3, WireType.Varint).uint32(message.uid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message face.GetRecordUserRequest
 */
export const GetRecordUserRequest = new GetRecordUserRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Res$Type extends MessageType<Res> {
    constructor() {
        super("face.Res", [
            { no: 1, name: "result", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Res>): Res {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = "";
        message.error = "";
        if (value !== undefined)
            reflectionMergePartial<Res>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Res): Res {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string result */ 1:
                    message.result = reader.string();
                    break;
                case /* string error */ 2:
                    message.error = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Res, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string result = 1; */
        if (message.result !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.result);
        /* string error = 2; */
        if (message.error !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message face.Res
 */
export const Res = new Res$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResFace$Type extends MessageType<ResFace> {
    constructor() {
        super("face.ResFace", [
            { no: 1, name: "result", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "featureData", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "imageData", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ResFace>): ResFace {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = "";
        message.error = "";
        message.featureData = "";
        message.imageData = "";
        if (value !== undefined)
            reflectionMergePartial<ResFace>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResFace): ResFace {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string result */ 1:
                    message.result = reader.string();
                    break;
                case /* string error */ 2:
                    message.error = reader.string();
                    break;
                case /* string featureData */ 3:
                    message.featureData = reader.string();
                    break;
                case /* string imageData */ 4:
                    message.imageData = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResFace, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string result = 1; */
        if (message.result !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.result);
        /* string error = 2; */
        if (message.error !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.error);
        /* string featureData = 3; */
        if (message.featureData !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.featureData);
        /* string imageData = 4; */
        if (message.imageData !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.imageData);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message face.ResFace
 */
export const ResFace = new ResFace$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResData$Type extends MessageType<ResData> {
    constructor() {
        super("face.ResData", [
            { no: 1, name: "result", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "data", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ServiceInfo }
        ]);
    }
    create(value?: PartialMessage<ResData>): ResData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = "";
        message.error = "";
        message.data = [];
        if (value !== undefined)
            reflectionMergePartial<ResData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResData): ResData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string result */ 1:
                    message.result = reader.string();
                    break;
                case /* string error */ 2:
                    message.error = reader.string();
                    break;
                case /* repeated face.ServiceInfo data */ 3:
                    message.data.push(ServiceInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string result = 1; */
        if (message.result !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.result);
        /* string error = 2; */
        if (message.error !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.error);
        /* repeated face.ServiceInfo data = 3; */
        for (let i = 0; i < message.data.length; i++)
            ServiceInfo.internalBinaryWrite(message.data[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message face.ResData
 */
export const ResData = new ResData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServiceInfo$Type extends MessageType<ServiceInfo> {
    constructor() {
        super("face.ServiceInfo", [
            { no: 1, name: "deviceId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "serviceId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ServiceInfo>): ServiceInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.deviceId = "";
        message.serviceId = "";
        message.status = "";
        if (value !== undefined)
            reflectionMergePartial<ServiceInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServiceInfo): ServiceInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string deviceId */ 1:
                    message.deviceId = reader.string();
                    break;
                case /* string serviceId */ 2:
                    message.serviceId = reader.string();
                    break;
                case /* string status */ 3:
                    message.status = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServiceInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string deviceId = 1; */
        if (message.deviceId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.deviceId);
        /* string serviceId = 2; */
        if (message.serviceId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.serviceId);
        /* string status = 3; */
        if (message.status !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message face.ServiceInfo
 */
export const ServiceInfo = new ServiceInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResMsg$Type extends MessageType<ResMsg> {
    constructor() {
        super("face.ResMsg", [
            { no: 1, name: "result", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "msg", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ResMsg>): ResMsg {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = "";
        message.error = "";
        message.msg = "";
        if (value !== undefined)
            reflectionMergePartial<ResMsg>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResMsg): ResMsg {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string result */ 1:
                    message.result = reader.string();
                    break;
                case /* string error */ 2:
                    message.error = reader.string();
                    break;
                case /* string msg */ 3:
                    message.msg = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResMsg, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string result = 1; */
        if (message.result !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.result);
        /* string error = 2; */
        if (message.error !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.error);
        /* string msg = 3; */
        if (message.msg !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.msg);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message face.ResMsg
 */
export const ResMsg = new ResMsg$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResRecordMsg$Type extends MessageType<ResRecordMsg> {
    constructor() {
        super("face.ResRecordMsg", [
            { no: 1, name: "result", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "fno", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "right", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "feature", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "msg", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "length", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ResRecordMsg>): ResRecordMsg {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = "";
        message.fno = 0;
        message.right = 0;
        message.feature = "";
        message.msg = "";
        message.length = 0;
        message.error = "";
        if (value !== undefined)
            reflectionMergePartial<ResRecordMsg>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResRecordMsg): ResRecordMsg {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string result */ 1:
                    message.result = reader.string();
                    break;
                case /* uint32 fno */ 2:
                    message.fno = reader.uint32();
                    break;
                case /* uint32 right */ 3:
                    message.right = reader.uint32();
                    break;
                case /* string feature */ 4:
                    message.feature = reader.string();
                    break;
                case /* string msg */ 5:
                    message.msg = reader.string();
                    break;
                case /* uint32 length */ 6:
                    message.length = reader.uint32();
                    break;
                case /* string error */ 7:
                    message.error = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResRecordMsg, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string result = 1; */
        if (message.result !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.result);
        /* uint32 fno = 2; */
        if (message.fno !== 0)
            writer.tag(2, WireType.Varint).uint32(message.fno);
        /* uint32 right = 3; */
        if (message.right !== 0)
            writer.tag(3, WireType.Varint).uint32(message.right);
        /* string feature = 4; */
        if (message.feature !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.feature);
        /* string msg = 5; */
        if (message.msg !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.msg);
        /* uint32 length = 6; */
        if (message.length !== 0)
            writer.tag(6, WireType.Varint).uint32(message.length);
        /* string error = 7; */
        if (message.error !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message face.ResRecordMsg
 */
export const ResRecordMsg = new ResRecordMsg$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResVersion$Type extends MessageType<ResVersion> {
    constructor() {
        super("face.ResVersion", [
            { no: 1, name: "result", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ResVersion>): ResVersion {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<ResVersion>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResVersion): ResVersion {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string result */ 1:
                    message.result = reader.string();
                    break;
                case /* string version */ 2:
                    message.version = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResVersion, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string result = 1; */
        if (message.result !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.result);
        /* string version = 2; */
        if (message.version !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message face.ResVersion
 */
export const ResVersion = new ResVersion$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResTotal$Type extends MessageType<ResTotal> {
    constructor() {
        super("face.ResTotal", [
            { no: 1, name: "result", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "total", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ResTotal>): ResTotal {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = "";
        message.total = 0;
        if (value !== undefined)
            reflectionMergePartial<ResTotal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResTotal): ResTotal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string result */ 1:
                    message.result = reader.string();
                    break;
                case /* uint32 total */ 2:
                    message.total = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResTotal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string result = 1; */
        if (message.result !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.result);
        /* uint32 total = 2; */
        if (message.total !== 0)
            writer.tag(2, WireType.Varint).uint32(message.total);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message face.ResTotal
 */
export const ResTotal = new ResTotal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResFno$Type extends MessageType<ResFno> {
    constructor() {
        super("face.ResFno", [
            { no: 1, name: "result", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "fno", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "right", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ResFno>): ResFno {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = "";
        message.fno = 0;
        message.right = 0;
        message.error = "";
        if (value !== undefined)
            reflectionMergePartial<ResFno>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResFno): ResFno {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string result */ 1:
                    message.result = reader.string();
                    break;
                case /* uint32 fno */ 2:
                    message.fno = reader.uint32();
                    break;
                case /* uint32 right */ 3:
                    message.right = reader.uint32();
                    break;
                case /* string error */ 4:
                    message.error = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResFno, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string result = 1; */
        if (message.result !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.result);
        /* uint32 fno = 2; */
        if (message.fno !== 0)
            writer.tag(2, WireType.Varint).uint32(message.fno);
        /* uint32 right = 3; */
        if (message.right !== 0)
            writer.tag(3, WireType.Varint).uint32(message.right);
        /* string error = 4; */
        if (message.error !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message face.ResFno
 */
export const ResFno = new ResFno$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResUserRight$Type extends MessageType<ResUserRight> {
    constructor() {
        super("face.ResUserRight", [
            { no: 1, name: "result", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "fno", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "right", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ResUserRight>): ResUserRight {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = "";
        message.fno = 0;
        message.right = 0;
        if (value !== undefined)
            reflectionMergePartial<ResUserRight>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResUserRight): ResUserRight {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string result */ 1:
                    message.result = reader.string();
                    break;
                case /* uint32 fno */ 2:
                    message.fno = reader.uint32();
                    break;
                case /* uint32 right */ 3:
                    message.right = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResUserRight, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string result = 1; */
        if (message.result !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.result);
        /* uint32 fno = 2; */
        if (message.fno !== 0)
            writer.tag(2, WireType.Varint).uint32(message.fno);
        /* uint32 right = 3; */
        if (message.right !== 0)
            writer.tag(3, WireType.Varint).uint32(message.right);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message face.ResUserRight
 */
export const ResUserRight = new ResUserRight$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResUserInfo$Type extends MessageType<ResUserInfo> {
    constructor() {
        super("face.ResUserInfo", [
            { no: 1, name: "result", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "total", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "data", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => UserInfo }
        ]);
    }
    create(value?: PartialMessage<ResUserInfo>): ResUserInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = "";
        message.total = 0;
        message.data = [];
        if (value !== undefined)
            reflectionMergePartial<ResUserInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResUserInfo): ResUserInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string result */ 1:
                    message.result = reader.string();
                    break;
                case /* uint32 total */ 2:
                    message.total = reader.uint32();
                    break;
                case /* repeated face.UserInfo data */ 3:
                    message.data.push(UserInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResUserInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string result = 1; */
        if (message.result !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.result);
        /* uint32 total = 2; */
        if (message.total !== 0)
            writer.tag(2, WireType.Varint).uint32(message.total);
        /* repeated face.UserInfo data = 3; */
        for (let i = 0; i < message.data.length; i++)
            UserInfo.internalBinaryWrite(message.data[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message face.ResUserInfo
 */
export const ResUserInfo = new ResUserInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserInfo$Type extends MessageType<UserInfo> {
    constructor() {
        super("face.UserInfo", [
            { no: 1, name: "fno", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "right", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<UserInfo>): UserInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fno = 0;
        message.right = 0;
        if (value !== undefined)
            reflectionMergePartial<UserInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserInfo): UserInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 fno */ 1:
                    message.fno = reader.uint32();
                    break;
                case /* uint32 right */ 2:
                    message.right = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 fno = 1; */
        if (message.fno !== 0)
            writer.tag(1, WireType.Varint).uint32(message.fno);
        /* uint32 right = 2; */
        if (message.right !== 0)
            writer.tag(2, WireType.Varint).uint32(message.right);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message face.UserInfo
 */
export const UserInfo = new UserInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResFeature$Type extends MessageType<ResFeature> {
    constructor() {
        super("face.ResFeature", [
            { no: 1, name: "result", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "fno", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "right", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "feature", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ResFeature>): ResFeature {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = "";
        message.fno = 0;
        message.right = 0;
        message.feature = "";
        if (value !== undefined)
            reflectionMergePartial<ResFeature>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResFeature): ResFeature {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string result */ 1:
                    message.result = reader.string();
                    break;
                case /* uint32 fno */ 2:
                    message.fno = reader.uint32();
                    break;
                case /* uint32 right */ 3:
                    message.right = reader.uint32();
                    break;
                case /* string feature */ 4:
                    message.feature = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResFeature, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string result = 1; */
        if (message.result !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.result);
        /* uint32 fno = 2; */
        if (message.fno !== 0)
            writer.tag(2, WireType.Varint).uint32(message.fno);
        /* uint32 right = 3; */
        if (message.right !== 0)
            writer.tag(3, WireType.Varint).uint32(message.right);
        /* string feature = 4; */
        if (message.feature !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.feature);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message face.ResFeature
 */
export const ResFeature = new ResFeature$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResFnoList$Type extends MessageType<ResFnoList> {
    constructor() {
        super("face.ResFnoList", [
            { no: 1, name: "result", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "fnoList", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ResFnoList>): ResFnoList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = "";
        message.fnoList = [];
        message.error = "";
        if (value !== undefined)
            reflectionMergePartial<ResFnoList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResFnoList): ResFnoList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string result */ 1:
                    message.result = reader.string();
                    break;
                case /* repeated uint32 fnoList */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.fnoList.push(reader.uint32());
                    else
                        message.fnoList.push(reader.uint32());
                    break;
                case /* string error */ 3:
                    message.error = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResFnoList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string result = 1; */
        if (message.result !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.result);
        /* repeated uint32 fnoList = 2; */
        if (message.fnoList.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.fnoList.length; i++)
                writer.uint32(message.fnoList[i]);
            writer.join();
        }
        /* string error = 3; */
        if (message.error !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message face.ResFnoList
 */
export const ResFnoList = new ResFnoList$Type();
/**
 * @generated ServiceType for protobuf service face.Face
 */
export const Face = new ServiceType("face.Face", [
    { name: "GetFaceApiStatus", options: {}, I: GetEmptyRequest, O: Res },
    { name: "UnRegisterFace", options: {}, I: GetFaceUuidRequest, O: Res },
    { name: "CompareFaceFeature", options: {}, I: GetUrlDeviceIdRequest, O: Res },
    { name: "DeleteFaceByUser", options: {}, I: GetUrlFaceByUserRequest, O: Res },
    { name: "GetFaceByUser", options: {}, I: GetUrlFaceByUserRequest, O: ResFace },
    { name: "UploadImage", options: {}, I: ImageMessage, O: Res },
    { name: "RegisterByImage", options: {}, I: RegisterByImageRequest, O: Res }
]);
